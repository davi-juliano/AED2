# -*- coding: utf-8 -*-
"""Trabalho_Computacional-1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18NPwR9CHKth4beXgUo8iVQkEwicFCWTj

# Importações do Python
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install pillow

import sys
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import csv
import time
from collections import Counter
from operator import itemgetter

"""# Abertura e Leitura do Arquivo"""

fornecedor=[]
destinos=[]
valor_respiradores=[]
data_entrega=[]
qnt_respiradores=[]

with open('distribuicao_respiradores_new.csv', newline='') as dist:
  leitor = csv.DictReader(dist)
  for key in leitor:
    for i in range(len(key)):
      fornecedor.append(key['FORNECEDOR'])
      qnt_respiradores.append(int(key['QUANTIDADE']))
      destinos.append(key['DESTINO'])
      valor_respiradores.append(float(key['VALOR']))
      data_entrega.append(key['DATA'])

"""# Códigos Utilizados na Análise

Código do Quick Sort:
"""

#Função do Prof. Hallison Paz (Infnet) com ordenação por QuickSort
# Vídeo "Quick Sort": https://youtu.be/wx5juM9bbFo
def quicksort(lista, inicio=0, fim=None):
    if fim is None:
        fim = (len(lista)-1)
    if inicio < fim:
        p = partition(lista, inicio, fim)
        # recursivamente na sublista à esquerda (menores)
        quicksort(lista, inicio, p-1)
        # recursivamente na sublista à direita (maiores)
        quicksort(lista, p+1, fim)

def partition(lista, inicio, fim):
    pivot = lista[fim]
    i = inicio
    for j in range(inicio, fim):
        # j sempre avança, pois representa o elementa em análise
        # e delimita os elementos maiores que o pivô
        if lista[j] <= pivot:
            lista[j], lista[i] = lista[i], lista[j]
            # incrementa-se o limite dos elementos menores que o pivô
            i = i + 1
    lista[i], lista[fim] = lista[fim], lista[i]
    return i

"""Código do Counting Sort:"""

#Função do Prof. André Backes (UFU) com ordenação por CountingSort
#Adaptada para o Python pelo autor do trabalho
#Vídeo "Counting Sort": https://www.youtube.com/watch?v=En8daEdcpJU&ab_channel=LinguagemCPrograma%C3%A7%C3%A3oDescomplicada

def countingsort(lista):
  fim=len(lista)
  baldes=[0 for i in range(2000)]

  for j in range(fim):
    baldes[lista[j]] += 1

  i=0
  for j in range(2000):
    k=baldes[j]
    while k>0:
      lista[i]=j
      i+=1
      k-=1

"""Código do Selection Sort:"""

#Código do Prof. Fabio Kon (prof do IME/USP) no Algoritmo de Seleção
#Link do vídeo: https://www.youtube.com/watch?v=JggjFK5PkMs&ab_channel=CCSLdoIME%2FUSP

def selecao(lista):
  fim=len(lista)
  for i in range(fim-1):
    posicao_minimo = i
    for j in range(i+1, fim):
      if lista[j] < lista[posicao_minimo]:
        posicao_minimo = j

      lista[i], lista[posicao_minimo] = lista[posicao_minimo], lista[i]

"""# Análise do Arquivo

Primeira Questão - Qual a média dos valores dos respiradores?
"""

def media(lst, lista): 
    return sum(lst) / sum(lista) 

#Utilizando a função media, temos

valor_medio = media(valor_respiradores, qnt_respiradores)
print(f'O valor medio é {valor_medio}')

"""Segunda Questão - Quais foram as maiores quantidades de respiradores distribuídos dentro de uma determinada encomenda? Plote o gráfico das quantidades

Quantidade no Quick Sort:
"""

quantidade = qnt_respiradores

#Para que o quicksort rodasse com a quantidade de valores dentro do colab, utilizamos essa funcao para aumentar a quantidade de recursoes permitidas
sys.setrecursionlimit(max(sys.getrecursionlimit(), len(quantidade)+10000))

ini=time.time()
quicksort(quantidade)
fim=time.time()

print(quantidade)
print(len(quantidade))
print(f'Tempo de execução: {fim-ini} segundos')

"""Quantidade no Counting Sort:"""

quantidade = qnt_respiradores
fim_vet = len(quantidade)

ini=time.time()
countingsort(quantidade)
fim=time.time()

print(quantidade)
print(len(quantidade))
print(f'Tempo de execução: {fim-ini} segundos')

"""Quantidade no Selection Sort:"""

quantidade = qnt_respiradores
fim_vet = len(quantidade)

ini=time.time()
selecao(quantidade)
fim=time.time()

print(quantidade)
print(len(quantidade))
print(f'Tempo de execução: {fim-ini} segundos')

"""Gráfico e Ordenação por Quick Sort do Counter das Quantidades:"""

dict_quantidade = dict(Counter(quantidade))
lista=[]
lista_valores=[]
lista=list(dict_quantidade.items())
for i in range(len(lista)):
  tupla = lista[i]
  lista_valores.append(tupla[1])

print(lista_valores) 

ini=time.time()
quicksort(lista_valores)
fim=time.time()

print(lista_valores)
print(len(lista_valores))
print(f'Tempo de execução: {fim-ini} segundos')

tuplas = sorted(dict_quantidade.items(), key=itemgetter(1), reverse=False)

lista_chaves=[]

for i in range(len(tuplas)):
  tupla = tuplas[i]
  lista_chaves.append(tupla[0])

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
plt.xticks(rotation=90)
ax.bar(lista_chaves, lista_valores)
plt.savefig('quantidade.png', bbox_inches = "tight")
plt.show()

"""Terceira Questão - Quais foram os destinos mais escolhidos em encomendas? Mostre por meio de um gráfico.

Gráfico e Ordenação por meio do Selection Sort do Counter dos Fornecedores:
"""

dict_fornecedor = dict(Counter(fornecedor))
lista=[]
lista_valores=[]
lista=list(dict_fornecedor.items())
for i in range(len(lista)):
  tupla = lista[i]
  lista_valores.append(tupla[1])

print(lista_valores) 

ini=time.time()
selecao(lista_valores)
fim=time.time()

print(lista_valores)
print(len(lista_valores))
print(f'Tempo de execução: {fim-ini} segundos')

#Como eu não sabia ordenar usando as tuplas, utilizei o sorted simplesmente para plotar os gráficos

tuplas = sorted(dict_fornecedor.items(), key=itemgetter(1), reverse=False)

lista_chaves=[]

for i in range(len(tuplas)):
  tupla = tuplas[i]
  lista_chaves.append(tupla[0])

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
plt.xticks(rotation=90)
ax.bar(lista_chaves, lista_valores)
plt.savefig('fornecedor.png', bbox_inches = "tight")
plt.show()

"""Quarta Questão - Quais foram os fornecedores que realizaram mais encomendas? Mostre por meio de um gráfico.

Gráfico e Ordenação por meio do Counting Sort do Counter dos Destinos:
"""

dict_destinos = dict(Counter(destinos))
lista=[]
lista_valores=[]
lista=list(dict_destinos.items())
for i in range(len(lista)):
  tupla = lista[i]
  lista_valores.append(tupla[1])

print(lista_valores) 

ini=time.time()
countingsort(lista_valores)
fim=time.time()

print(lista_valores)
print(len(lista_valores))
print(f'Tempo de execução: {fim-ini} segundos')

tuplas = sorted(dict_destinos.items(), key=itemgetter(1), reverse=False)

lista_chaves=[]

for i in range(len(tuplas)):
  tupla = tuplas[i]
  lista_chaves.append(tupla[0])

fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
plt.xticks(rotation=90)
ax.bar(lista_chaves, lista_valores)
plt.savefig('destinos.png', bbox_inches = "tight")
plt.show()